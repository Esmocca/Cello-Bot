#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <FluxGarage_RoboEyes.h>
#include <MPU9250_WE.h>

// IMU SENSOR
#define MPUADDR 0x68
MPU9250_WE imu(MPUADDR);

// OLED
#define SCREENWIDTH 128
#define SCREENHEIGHT 64
#define OLEDRESET -1

#define PITCH_THRESHOLD 20.0   // derajat
#define YAW_RATE_THRESHOLD 80.0 // deg/s

#define IDLETIME 60000

#define STABLE_DELTA_THRESHOLD   1.0     // derajat
#define UNSTABLE_TIME_THRESHOLD  400     // ms
#define LDR_DARK_THRESHOLD 10   // makin kecil = makin gelap
enum RobotState {
  STATE_IDLE,
  STATE_ANGRY,
  STATE_TIRED,
  STATE_HAPPY
};

RobotState currentState = STATE_IDLE;

Adafruit_SSD1306 display(SCREENWIDTH, SCREENHEIGHT, &Wire, OLEDRESET);
RoboEyes<Adafruit_SSD1306> roboEyes(display); 

const int ldrPin = A0;

float roll = 0.0;
float pitch = 0.0;
float rollAcc;
float pitchAcc;

float lastRoll = 0.0;
float lastPitch = 0.0;
unsigned long unstableStartTime = 0;

unsigned long prevTime;
float dt;

unsigned long lastMotionTime;
unsigned long motionStartTime = 0;
unsigned long nowMillis;

void setup() {
  Serial.begin(115200);
  Wire.begin();
  pinMode(ldrPin, INPUT);

  // OLED init
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println("OLED failed");
    while(1);
  }

  roboEyes.begin(SCREENWIDTH, SCREENHEIGHT, 100);
  roboEyes.setWidth(36, 36);
  roboEyes.setHeight(36, 36);
  roboEyes.setBorderradius(8, 8);
  roboEyes.setSpacebetween(10);
  roboEyes.setCyclops(OFF);
  roboEyes.setAutoblinker(ON, 3, 2);
  roboEyes.setIdleMode(ON, 2, 2);

  Wire.beginTransmission(MPUADDR);
  Wire.write(0x6B);     
  Wire.write(0x00);
  Wire.endTransmission();

  prevTime = micros();
  lastMotionTime = millis();
}

void ReadIMU() {
  xyzFloat acc = imu.getAccRawValues();
  xyzFloat gyr = imu.getGyrRawValues();

  float accX = acc.x / 16384.0;
  float accY = acc.y / 16384.0;
  float accZ = acc.z / 16384.0;

  float gyroX = gyr.x / 131.0;
  float gyroY = gyr.y / 131.0;

  rollAcc  = atan2(accY, accZ) * 57.2958;
  pitchAcc = atan2(-accX, sqrt(accY * accY + accZ * accZ)) * 57.2958;

  unsigned long now = micros();
  dt = (now - prevTime) * 1e-6;
  prevTime = now;

  roll  += gyroX * dt;
  pitch += gyroY * dt;

  roll  = 0.98 * roll  + 0.02 * rollAcc;
  pitch = 0.98 * pitch + 0.02 * pitchAcc;

}

bool isOrientationStable() {
  float dRoll  = abs(roll - lastRoll);
  float dPitch = abs(pitch - lastPitch);

  lastRoll  = roll;
  lastPitch = pitch;

  // perubahan kecil → stabil
  if (dRoll < STABLE_DELTA_THRESHOLD && dPitch < STABLE_DELTA_THRESHOLD) {
    unstableStartTime = 0;
    return true;
  }

  // perubahan besar → mulai hitung
  if (unstableStartTime == 0)
    unstableStartTime = millis();

  // jika terus berubah cukup lama → tidak stabil
  if (millis() - unstableStartTime > UNSTABLE_TIME_THRESHOLD)
    return false;

  return true;
}

void updateState() {
  unsigned long nowMillis = millis();
  bool stable = isOrientationStable();

  // TIDAK STABIL → ANGRY
  if (!stable) {
    currentState = STATE_ANGRY;
    lastMotionTime = nowMillis;
    return;
  }

  if (isPatDetected()) {
    currentState = STATE_HAPPY;
    return;
  }

  // STABIL
  if (nowMillis - lastMotionTime > IDLETIME)
    currentState = STATE_TIRED;
  else
    currentState = STATE_IDLE;
}


void updateEyes() {
  static RobotState lastState = STATE_IDLE;

  if (currentState == lastState) return;
  lastState = currentState;

  switch (currentState) {
    case STATE_ANGRY:
      roboEyes.setMood(ANGRY);
      roboEyes.anim_confused();
      break;

    case STATE_IDLE:
      roboEyes.setMood(DEFAULT);
      roboEyes.setPosition(DEFAULT);
      break;

    case STATE_TIRED:
      roboEyes.setMood(TIRED);
      break;

    case STATE_HAPPY:
      roboEyes.setMood(HAPPY);
      roboEyes.anim_laugh();
      break;
  }
}

bool isPatDetected() {
  float ldr = analogRead(ldrPin);
  return (ldr < LDR_DARK_THRESHOLD);
}


void OLED(){
  roboEyes.begin(SCREENWIDTH, SCREENHEIGHT, 100);

  roboEyes.setAutoblinker(ON, 3, 2);
  roboEyes.setIdleMode(ON, 2, 2);

  // Define eye shapes, all values in pixels
  roboEyes.setWidth(36, 36); // byte leftEye, byte rightEye
  roboEyes.setHeight(36, 36); // byte leftEye, byte rightEye
  roboEyes.setBorderradius(8, 8); // byte leftEye, byte rightEye
  roboEyes.setSpacebetween(10); // int space -> can also be negative

  // Cyclops mode
  roboEyes.setCyclops(ON); // bool on/off -> if turned on, robot has only on eye

  // Define mood, curiosity and position
  roboEyes.setMood(DEFAULT); // mood expressions, can be TIRED, ANGRY, HAPPY, DEFAULT
  roboEyes.setPosition(DEFAULT); // cardinal directions, can be N, NE, E, SE, S, SW, W, NW, DEFAULT (default = horizontally and vertically centered)
  roboEyes.setCuriosity(ON); // bool on/off -> when turned on, height of the outer eyes increases when moving to the very left or very right

  // Set horizontal or vertical flickering
  roboEyes.setHFlicker(ON, 2); // bool on/off, byte amplitude -> horizontal flicker: alternately displacing the eyes in the defined amplitude in pixels
  roboEyes.setVFlicker(ON, 2); // bool on/off, byte amplitude -> vertical flicker: alternately displacing the eyes in the defined amplitude in pixels

  // Play prebuilt oneshot animations
  roboEyes.anim_confused(); // confused - eyes shaking left and right
  roboEyes.anim_laugh(); // laughing - eyes shaking up and down

}

void loop(){
  ReadIMU();
  updateState();
  updateEyes();
  roboEyes.update();

  Serial.print("Roll: ");
  Serial.print(roll, 2);
  Serial.print(" | Pitch: ");
  Serial.println(pitch, 2);

  delay(10);

}
